---
title: "Métataxonomie des bactéries du fromage"
author: [Gustavo Magaña López, Théo Roncalli]
date: "18/11/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

```{r lib.import}
library(matR)
library(tidyverse)
library(reshape2)
library(parallel)
library(foreach)
library(doParallel)
library(stringr)
library(doRNG)
```

```{r data.import}
# Read raw data, the initial dot implies these objects are not 
# supposed to be used directly
# The identifier should be read as a string 
.metadata.df <- within(read.table("MetadataCheese.csv", header = T), {
  ID <- as.character(ID)
})
.metadata.tb <- tibble(.metadata.df)

.backup.file <- "biom_phylum.rds"
if (!file.exists(.backup.file)){
  #List des accessions associées à l'étude mgp3362 
  # (2 échantillons absents des métadonnées)
  list_mgp3362 <- metadata("mgp3362")$mgp3362
  list_mgp3362 <- list_mgp3362[c(-11,-22)]
  #Récupération des données taxonomiques (request='organism') depuis les hits
  #de la base de données RDP (source='RDP') au niveau de l'ordre (group_level='order')
  #avec une evalue de 1e-15 (evalue=15)
  biom_phylum <- biomRequest(
    list_mgp3362, request="organism", source="RDP",
    group_level="order", evalue=15, wait=TRUE
  )
  saveRDS(biom_phylum, .backup.file)
} else {
  biom_phylum <- readRDS(.backup.file)
}

#Transformation en matrice
.phylum.matrix <- as.matrix(biom_phylum)
clean_data_frame <- function(my.matrix){
  #' Convert a matrix to a dataframe, 
  #' eliminating null columns
  .df <- as.data.frame(my.matrix)
  .null.col.sums <- colSums(.df) == 0
  .to.drop <- .null.col.sums[.null.col.sums]
  .cols.to.drop <- names(.to.drop)
  .clean.df <- .df[, !colnames(.df) %in% .cols.to.drop]
  .retval <- list(
    clean.df=.clean.df,
    null.cols=.cols.to.drop
  )
  return(.retval)
}

.clean <- clean_data_frame(.phylum.matrix)
phylum.df <- .clean$clean.df
phylum.matrix <- as.matrix(phylum.df)
phylum.tb <- phylum.df %>% rownames_to_column("Strain") %>% as_tibble()


.null.cols.chr <- .clean$null.cols %>% 
  # this regex matches numbers with at least one decimal, 
  # preceded by three letters (as our IDs are conigured)
  # letters are not captured
  str_match("(?<=[:alpha:]{3})[:digit:]+\\.[:digit:]+") %>% 
  as.character()

metadata.tb <- .metadata.tb %>% filter(!ID %in% .null.cols.chr)
metadata.df <- metadata.tb %>% column_to_rownames("ID")

#str_match(.clean$null.cols, "(?<=[:alpha:]{3})[:digit:]+") %>% as.character() %>% as.numeric()
#.clean$null.cols %>% purrr::map(~ stringr::str_match(.x, "(?<=[:alpha:]{3})[:digit:]+") %>% as.numeric)
```


Les courbes de raréfaction doivent être par échantillon.

```{r rarefaction.curve, cache=T}
otus <- phylum.df %>% rownames
samples <- phylum.df %>% colnames
phylum.prob.df <- apply(phylum.df, 2, function(x){ x / sum(x)})


library(doParallel)
cl <- makeCluster(parallel::detectCores())
registerDoParallel(cl)
set.seed(1234)

.n.replicas <- 500
tryCatch(
  rarefactions.tb <- foreach(
    i=samples, .inorder = F, .combine = rbind, 
    .packages = c("magrittr", "tibble", "stringr")
  ) %dorng% {
    .nb.seq <- seq(1, sum(phylum.df[,i]), 20)
    .n.taxa <- vector("numeric", length = length(.nb.seq))
    for (j in seq_along(.nb.seq)){
     .n.taxa[j] <- replicate(.n.replicas, 
       sample(otus, .nb.seq[j], prob = phylum.prob.df[,i], replace = T) %>% 
         unique %>% length
      ) %>% mean
     #.n.taxa <- c(.n.taxa, .tax)
    }
    tibble(
      `Nombre de Séquences`=.nb.seq, 
      `Nombre d'OTU`=.n.taxa,
      `Échantillon`=i %>% 
        str_match("(?<=[:alpha:]{3})[:digit:]+") %>% 
        as.character()
    )
  }, 
  finally = stopCluster(cl)
)



rarefactions.tb %>% 
  ggplot(aes(x=`Nombre de Séquences`, y=`Nombre d'OTU`)) +
    geom_line(aes(colour=`Échantillon`)) + 
      labs(title = glue::glue("Diversité alpha, moyenne sur {.n.replicas} répliques"))

#rarefactions.ls[[1]] %>% 
#  ggplot(aes(x=nSeq, y=nOTU)) + geom_line() + geom_smooth()
```

```{r shannon}
H <- function(x){ 
  #' Shannon's entropy
  p <- x[x > 0] 
  - sum(p * log(p)) 
}

shannon <- apply(phylum.prob.df, 2, H)
```


```{r pca.lda}
#Chargement du package MASS
library(MASS)
## NB la matrice de données doit être transformée
LDA<-lda(x=t(phylum.matrix),grouping=metadata.df$Pasteurized)

## Calcul des valeurs pour chaque groupe
LDA1_RawMilk <- colSums(apply(phylum.matrix[,metadata.df$Pasteurized=='N'],2,
function(x){LDA$scaling*x}))

LDA1_Pasteurized<-colSums(apply(phylum.matrix[,metadata.df$Pasteurized=='Y'],2,
function(x){LDA$scaling*x}))

#Représentation sous forme d'histogramme
plot.new()
hist(LDA1_Pasteurized, xlim=c(min(LDA1_RawMilk)-4, max(LDA1_Pasteurized)+1),
     col='green', xlab='LD1 means', ylab='Frequency', main='Predicted Values'
)

hist(LDA1_RawMilk,col='red',add=T)
legend('topleft',pch=19,col=c('red','green'),legend = c('Raw','Pasteurized'))

```


```{r other.plot}
par(mar=c(15,5,5,5))
barplot(LDA$scaling[,1],names.arg = rownames(LDA$scaling),las=2,
col='black',cex.names = 0.76)
```


```{r acp}
#lda(x=t(phylum_matrix),grouping=metadata$Pasteurized)
pca_res <- acp <- prcomp(t(phylum.prob.df), scale = F)
biplot(acp)
acp$x[,1:2] %>% as.data.frame() %>% ggplot(aes(PC1, PC2)) + geom_point()

var_explained <- pca_res$sdev^2/sum(pca_res$sdev^2)
pca_res$x %>% 
  as.data.frame %>%
  ggplot(aes(x=PC1,y=PC2)) + geom_point(size=4) +
  theme_bw(base_size=32) + 
  labs(x=paste0("PC1: ",round(var_explained[1]*100,1),"%"),
       y=paste0("PC2: ",round(var_explained[2]*100,1),"%")) +
  theme(legend.position="top")
```